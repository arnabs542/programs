# Toughest things about graphs is to identify it's a graph problem. Once it's identified, there are only few things to apply:
  => BFS, DFS, Visited, Cycle
  => Shortest / closest - BFS
  => Connected / Longest / Path b/w nodes - DFS

# Algo Design Manual- Steven Skiena

# Degree of a node is the number of edges coming into a vertex. What's the sum of degree of all vertices?
    => Undirected : 2|E| as each edge will be counted twice, eg. A --- B (2)
    => Directed : In-degree Sum = Out-degree Sum = |E| as each edge will be counted once, eg. A ---> B (1,1)

==== Eulerian Cycle & Paths ====
# Hamiltonian Cycle problem & Travelling Salesman problem - NP Hard problems. No known polynomial time algo. It's mostly exponential time.
# Eulerian Cycle : Go through each edge exactly once & come back to the starting vertex, then it's a Eulerian cycle,
if not then it's an Eulerian Path (starts & ends at different vertices).
    => Hamiltonian cycle is about visiting each vertex exactly once vs Eulerian which is about visiting vertex once.
    => For a connected graph, it will always have an Eulerian cycle if -
        -> It's undirected & has all Even degree vertices.
        -> It's directed & in-degree = out-degree of all vertices.
        -> We can find Eulerian cycle path by backtracking(when all edges aren't visited) & doing mini-walks from last V.

# Number of odd degree vertices has to be even (can't be odd as Sum of degrees = 2|E| & odd+even = odd which contradicts it)

# Number of vertices with odd degree:
    => 0 - Eulerian Cycle
    => 2 - Eulerian Path
    => 4,6,8... - No Eulerian Cycle / Paths

# Graph representation largely depends upon how we store edges as they can be of order of C(n choose 2)=O(n^2) in worst case.
Hence, a simple operation like finding all neighbors of a vertex, might become O(n*m)=>O(n^3) operation eg. edge list representation.

# Trees don't have cycles, unlike Graphs. Graphs would always need visited tracking therefore.
# BFS Graph traversal can have exponential space complexity O(2^h), if branching out factor is large, like in trees.
# DFS Graph traversal will usually incur space complexity O(h) until recursion Stack depth

# For Graph problems, both DFS & BFS incurs O(m+n) runtime & O(n) space complexity, where n=vertices & m=edges.

# A graph is Bipartite, if we can split the vertices into 2 subsets such that edges go b/w 2 sets. Graph is Bipartite if -
    => No cycles - Yes
    => Odd length Cycles = Cross edge in the same layer - No

# Topological sort is an ordering of vertices of a graph based on some constraint.
    => Topo can't be done for graph with cycles.
    => In other words graph has to be a DAG (Undirected graphs too we can do topo sort provided there are no cycles)
    => Cycle detection becomes very important, where we fail fast instead of going into endless loop.
    => Can be done using DFS. Maintain visited = 0 for unvisited, 1 for being visited, 2 for visited
       -> Visit unvisited vertices in any order, mark them as 1 and dfs on it's neighbors
       -> If a neighboring vertex state is 1, it means it's a loop, Abort!
       -> Now this vertex state is 2, add it to result.
    => Can be done using BFS (Kahn's algo). Use in-degrees for each vertex, maintain a count of done vertices.
       -> Start with a zero degreed vertex, add to Queue
       -> For each of it's neighbors, decrease indegree count. Any new zero-degreed vertex is added to Queue.
       -> Now this vertex state is 2, add it to result. Increment count of done vertices.
       -> If done vertex count isn't equal to num vertices, then it's a cycle.